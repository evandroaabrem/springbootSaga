Arquitetura Final da SAGA (Kafka + Retry + DLT)
ğŸ¯ Objetivo da arquitetura

Garantir:

ConsistÃªncia eventual

IdempotÃªncia

Reprocessamento seguro

CompensaÃ§Ã£o controlada

Observabilidade

Sem depender de transaÃ§Ãµes distribuÃ­das.

ğŸ—ï¸ VisÃ£o Geral (macro)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ API / REST   â”‚
â”‚ TransferÃªnciaâ”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SagaOrchestratorService  â”‚
â”‚ (estado + decisÃ£o)       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ publica
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Kafka Topics (comandos)  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Listeners de DomÃ­nio     â”‚
â”‚ (DÃ©bito / CrÃ©dito)       â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ sucesso / falha
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Kafka Topics (eventos)   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SagaOrchestratorService  â”‚
â”‚ (prÃ³ximo passo)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ” Fluxo completo da transferÃªncia
1ï¸âƒ£ InÃ­cio da SAGA
POST /transferencias


AÃ§Ãµes:

Gera transactionId

Persiste SAGA como INICIADA

Publica evento:

transferencia-iniciada

2ï¸âƒ£ Orquestrador inicia o dÃ©bito
SagaOrchestrator
  â””â”€â”€> debito-comando


ğŸ“Œ O orquestrador nÃ£o executa lÃ³gica de negÃ³cio, apenas decide o fluxo.

3ï¸âƒ£ DÃ©bito (com retry e DLT)
@KafkaListener("debito-comando")
@RetryableTopic(...)


Fluxo:

Tenta debitar

Atualiza status â†’ DEBITADA

Publica:

debito-realizado


âŒ Se falhar apÃ³s retries:

debito-comando-DLT

4ï¸âƒ£ DLT de dÃ©bito (compensaÃ§Ã£o)
@KafkaListener("debito-comando-DLT")


AÃ§Ãµes:

Atualiza status â†’ FALHOU

Publica:

estorno-comando

5ï¸âƒ£ CrÃ©dito
@KafkaListener("credito-comando")


Fluxo:

Credita conta destino

Atualiza status â†’ CREDITADA

Publica:

credito-realizado


âŒ Falha:

credito-comando-DLT

6ï¸âƒ£ CompensaÃ§Ã£o de crÃ©dito
@KafkaListener("credito-comando-DLT")


AÃ§Ãµes:

Atualiza status â†’ COMPENSANDO

Publica:

estorno-comando

7ï¸âƒ£ FinalizaÃ§Ã£o
transferencia-finalizada


ou

transferencia-falhou


Status final:

âœ… FINALIZADA

âŒ CANCELADA

ğŸ§  Componentes e responsabilidades
SagaOrchestratorService

ResponsÃ¡vel por:

Validar estado atual

Decidir prÃ³ximo passo

Publicar comandos

ğŸš« NÃ£o executa dÃ©bito/crÃ©dito
ğŸš« NÃ£o acessa banco de contas

Listeners de domÃ­nio
Classe	FunÃ§Ã£o
DebitoListener	Executa dÃ©bito
CreditoListener	Executa crÃ©dito
EstornoListener	Executa estorno
DebitoDltListener	CompensaÃ§Ã£o
CreditoDltListener	CompensaÃ§Ã£o
SagaTransferenciaService

ResponsÃ¡vel por:

Atualizar estado com status esperado

Garantir idempotÃªncia

Registrar histÃ³rico

boolean atualizarStatusSeEsperado(
    txId,
    statusEsperado,
    novoStatus
);

ğŸ—ƒï¸ Modelo de dados recomendado
Tabela principal
saga_transferencia
- transaction_id (PK)
- status_atual
- created_at
- updated_at

HistÃ³rico
saga_transferencia_historico
- id
- transaction_id
- status
- origem_evento
- erro
- created_at

ğŸ“¦ TÃ³picos Kafka (padrÃ£o final)
Comandos
transferencia-iniciada
debito-comando
credito-comando
estorno-comando

Eventos
debito-realizado
credito-realizado
transferencia-finalizada

Retry / DLT
debito-comando-retry-2000
debito-comando-retry-4000
debito-comando-DLT

credito-comando-retry-2000
credito-comando-retry-4000
credito-comando-DLT

ğŸ›¡ï¸ Regras de ouro (produÃ§Ã£o)

âœ” Toda mudanÃ§a de status valida o estado anterior
âœ” DLT nÃ£o Ã© erro, Ã© fluxo de negÃ³cio
âœ” Mensagens nunca sÃ£o apagadas
âœ” Offset â‰  processamento concluÃ­do
âœ” CompensaÃ§Ã£o tambÃ©m Ã© idempotente

ğŸ§ª Como isso se comporta em falhas reais
CenÃ¡rio	Resultado
Kafka cai	Reprocessa
App reinicia	Continua
Mensagem duplicada	Ignorada
DÃ©bito falha	Compensa
CrÃ©dito falha	Compensa
ğŸ§­ PrÃ³ximo passo recomendado

Agora vocÃª tem arquitetura pronta.
O prÃ³ximo passo ideal Ã© refatorar o cÃ³digo para refletir isso.

ğŸ‘‰ Posso:

Refatorar suas classes (nomes + responsabilidades)

Criar o SagaOrchestrator completo

Criar endpoint de reprocessamento

Criar diagrama visual (ASCII ou explicativo)

Simular um caos real (falhas)

Qual vocÃª quer seguir agora?